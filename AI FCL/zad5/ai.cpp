//--------------------------------------------------------------------------------
// Code generated by jFuzzyLogic
// jFuzzyLogic Version : JFuzzyLogic 3.3 (build 2015-04-09), by Pablo Cingolani 
// jFuzzyLogic creted by Pablo Cingolani
//--------------------------------------------------------------------------------


#include <stdio.h>

#include <stdlib.h>
#include <iostream>
double ruleAccumulationMethod_max(double defuzzifierValue, double valueToAggregate) { return (defuzzifierValue > valueToAggregate ? defuzzifierValue : valueToAggregate); }

double ruleActivationMethod_min(double degreeOfSupport, double membership) { return (degreeOfSupport < membership ? degreeOfSupport : membership); }

double ruleConnectionMethod_and(double antecedent1, double antecedent2) { return (antecedent1 < antecedent2 ? antecedent1 : antecedent2); }

class FunctionBlock_name {

public:
	// VAR_INPUT
	double odleglosc;

	// VAR_OUTPUT
	double predkosc;

private:
	// FUZZIFY odleglosc
	double odleglosc_duza;
	double odleglosc_mala;
	double odleglosc_srednia;


	// DEFUZZIFY predkosc
	double defuzzify_predkosc[1000];


public:
	FunctionBlock_name();
	void calc();
	void print();

private:
	void defuzzify();
	void fuzzify();
	void reset();
	double membership_odleglosc_duza(double x);
	double membership_odleglosc_mala(double x);
	double membership_odleglosc_srednia(double x);
	double membership_predkosc_duza(double x);
	double membership_predkosc_mala(double x);
	double membership_predkosc_srednia(double x);
	void calc_No1();

};

// Constructor
FunctionBlock_name::FunctionBlock_name() {
	predkosc = 0.0;
}

// Calculate function block
void FunctionBlock_name::calc() {
	reset();
	fuzzify();
	calc_No1();
	defuzzify();
}

// RULEBLOCK No1
void FunctionBlock_name::calc_No1() {
	// RULE 1 : IF odleglosc IS mala THEN predkosc IS mala;
	double degreeOfSupport_1 = 1.0 * (odleglosc_mala);
	if (degreeOfSupport_1 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = 0.0 + i * 0.1;
			double membership = membership_predkosc_mala(x);
			double y = ruleActivationMethod_min(degreeOfSupport_1, membership);
			defuzzify_predkosc[i] += ruleAccumulationMethod_max(defuzzify_predkosc[i], y);
		}
	}

	// RULE 2 : IF odleglosc IS srednia THEN predkosc IS srednia;
	double degreeOfSupport_2 = 1.0 * (odleglosc_srednia);
	if (degreeOfSupport_2 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = 0.0 + i * 0.1;
			double membership = membership_predkosc_srednia(x);
			double y = ruleActivationMethod_min(degreeOfSupport_2, membership);
			defuzzify_predkosc[i] += ruleAccumulationMethod_max(defuzzify_predkosc[i], y);
		}
	}

	// RULE 3 : IF odleglosc IS duza THEN predkosc IS duza;
	double degreeOfSupport_3 = 1.0 * (odleglosc_duza);
	if (degreeOfSupport_3 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = 0.0 + i * 0.1;
			double membership = membership_predkosc_duza(x);
			double y = ruleActivationMethod_min(degreeOfSupport_3, membership);
			defuzzify_predkosc[i] += ruleAccumulationMethod_max(defuzzify_predkosc[i], y);
		}
	}

}

// Defuzzify 
void FunctionBlock_name::defuzzify() {
	double sum_predkosc = 0.0;
	double wsum_predkosc = 0.0;
	for (int i = 0; i < 1000; i++) {
		double x = 0.0 + i * 0.1;
		sum_predkosc += defuzzify_predkosc[i];
		wsum_predkosc += x * defuzzify_predkosc[i];
	}
	predkosc = wsum_predkosc / sum_predkosc;
}

// Fuzzify all variables
void FunctionBlock_name::fuzzify() {
	odleglosc_duza = membership_odleglosc_duza(odleglosc);
	odleglosc_mala = membership_odleglosc_mala(odleglosc);
	odleglosc_srednia = membership_odleglosc_srednia(odleglosc);
}

// Membership functions 
double FunctionBlock_name::membership_odleglosc_duza(double x) {
	if (x <= 650.0)	return 0.0;
	if (x > 1000.0)	return 1.0;
	if (x <= 850.0)	return 0.0 + (1.0 - 0.0) * ((x - 650.0) / (850.0 - 650.0));
	if (x <= 1000.0)	return 1.0 + (1.0 - 1.0) * ((x - 850.0) / (1000.0 - 850.0));
}

double FunctionBlock_name::membership_odleglosc_mala(double x) {
	if (x <= 0.0)	return 1.0;
	if (x > 350.0)	return 0.0;
	if (x <= 150.0)	return 1.0 + (1.0 - 1.0) * ((x - 0.0) / (150.0 - 0.0));
	if (x <= 350.0)	return 1.0 + (0.0 - 1.0) * ((x - 150.0) / (350.0 - 150.0));
}

double FunctionBlock_name::membership_odleglosc_srednia(double x) {
	if (x <= 250.0)	return 0.0;
	if (x > 750.0)	return 0.0;
	if (x <= 400.0)	return 0.0 + (1.0 - 0.0) * ((x - 250.0) / (400.0 - 250.0));
	if (x <= 600.0)	return 1.0 + (1.0 - 1.0) * ((x - 400.0) / (600.0 - 400.0));
	if (x <= 750.0)	return 1.0 + (0.0 - 1.0) * ((x - 600.0) / (750.0 - 600.0));
}

double FunctionBlock_name::membership_predkosc_duza(double x) {
	if (x <= 60.0)	return 0.0;
	if (x > 100.0)	return 1.0;
	if (x <= 75.0)	return 0.0 + (1.0 - 0.0) * ((x - 60.0) / (75.0 - 60.0));
	if (x <= 100.0)	return 1.0 + (1.0 - 1.0) * ((x - 75.0) / (100.0 - 75.0));
}

double FunctionBlock_name::membership_predkosc_mala(double x) {
	if (x <= 0.0)	return 1.0;
	if (x > 40.0)	return 0.0;
	if (x <= 25.0)	return 1.0 + (1.0 - 1.0) * ((x - 0.0) / (25.0 - 0.0));
	if (x <= 40.0)	return 1.0 + (0.0 - 1.0) * ((x - 25.0) / (40.0 - 25.0));
}

double FunctionBlock_name::membership_predkosc_srednia(double x) {
	if (x <= 30.0)	return 0.0;
	if (x > 70.0)	return 0.0;
	if (x <= 45.0)	return 0.0 + (1.0 - 0.0) * ((x - 30.0) / (45.0 - 30.0));
	if (x <= 55.0)	return 1.0 + (1.0 - 1.0) * ((x - 45.0) / (55.0 - 45.0));
	if (x <= 70.0)	return 1.0 + (0.0 - 1.0) * ((x - 55.0) / (70.0 - 55.0));
}


// Print 
void FunctionBlock_name::print() {
	printf("Function block name:\n");
	printf("	Input  %20s : %f\n", "odleglosc", odleglosc);
	printf("	       %20s : %f\n", "odleglosc_duza", odleglosc_duza);
	printf("	       %20s : %f\n", "odleglosc_mala", odleglosc_mala);
	printf("	       %20s : %f\n", "odleglosc_srednia", odleglosc_srednia);
	printf("	Output %20s : %f\n", "predkosc", predkosc);
}

// Reset output
void FunctionBlock_name::reset() {
	for (int i = 0; i < 1000; i++) { defuzzify_predkosc[i] = 0.0; }
}

int main(int argc, char* argv[]) {
	// Create function blocks
	FunctionBlock_name name;

	// Parse input
	if (argc > 1) { name.odleglosc = atof(argv[1]); }

	for (int i = name.odleglosc; i > 0; i--) {
		// Fuzzify
		name.odleglosc = i;
		name.calc();
		// Print
		std::cout << "\nodleglosc: " << name.odleglosc << ", predkosc: " << name.predkosc << std::endl;
	}
}
